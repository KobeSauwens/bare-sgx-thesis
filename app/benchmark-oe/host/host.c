// Copyright (c) Open Enclave SDK contributors.
// Licensed under the MIT License.

#define _GNU_SOURCE
#include <openenclave/host.h>
#include <stdio.h>
#include "../../../external/sgx-step/libsgxstep/debug.h"
#include <time.h> // For timing
#include <unistd.h>
#include <signal.h>
#include <ucontext.h>
#include <string.h>
#include "../../../external/sgx-step/libsgxstep/cpu.h"
#include "../../../external/sgx-step/libsgxstep/sched.h"
#include "../../../external/sgx-step/libsgxstep/enclave.h"
#include "../../../external/sgx-step/libsgxstep/pt.h"
#include "../../../external/sgx-step/libsgxstep/apic.h"
#include "../../../external/sgx-step/libsgxstep/cache.h"
#include "../../../external/sgx-step/libsgxstep/elf_parser.h"
#include <sys/mman.h>
// Include the untrusted helloworld header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the helloworld.edl file.

#include "oe_crypto_app_u.h"  // Generated by oeedger8r
#define TAG_LEN         32
#define DIGEST_LEN      32
#define KEY_LEN_AEAD    32
#define KEY_LEN_HMAC    16
#define MAC_LEN         16
#define KEY_LEN_AES     16
#define NONCE_LEN       12
#define NUM_SAMPLES     1000
#define DELAY           1
#define ITERATIONS      100000
#define DEBUG           0
#define ENCLAVE_DBG     1
#define ENCLAVE_PATH            "enclave/enclave.signed"
#define TAG_LEN 32
#define DATA "Bare-SGX rocks!"

uint64_t diff[NUM_SAMPLES];
void *encl_page = NULL;
uint64_t *pte_encl = 0;
int step_cnt = 0;

void print_args(
    oe_enclave_t* eid,
    const uint8_t* ciphertext, size_t ciphertext_len,
    const uint8_t* mac,
    const uint8_t* m, size_t mlen,
    const uint8_t* aad, size_t aadlen,
    const uint8_t* nonce, size_t noncelen
) {
    printf("=== ChaCha20-Poly1305 Enclave Call Arguments ===\n");

    printf("Plaintext [len: %zu]:\t", mlen);
    for (size_t i = 0; i < mlen; i++) printf("%02x ", m[i]);
    printf("\n");

    printf("AAD [len: %zu]:\t\t", aadlen);
    for (size_t i = 0; i < aadlen; i++) printf("%02x ", aad[i]);
    printf("\n");

    printf("Nonce [len: %zu]:\t", noncelen);
    for (size_t i = 0; i < noncelen; i++) printf("%02x ", nonce[i]);
    printf("\n");

    printf("Ciphertext [len: %zu]:\t", ciphertext_len);
    for (size_t i = 0; i < ciphertext_len; i++) printf("%02x ", ciphertext[i]);
    printf("\n");

    printf("MAC [len: 16]:\t\t");
    for (size_t i = 0; i < 16; i++) printf("%02x ", mac[i]);
    printf("\n");
}

void aep_cb_func(void)
{
    #if DEBUG
    uint64_t erip = edbgrd_erip() - (uint64_t)get_enclave_base();
    info("^^ enclave RIP=%#lx", erip);
    #endif
}

bool check_simulate_opt(int* argc, const char* argv[])
{
    for (int i = 0; i < *argc; i++)
    {
        if (strcmp(argv[i], "--simulate") == 0)
        {
            fprintf(stdout, "Running in simulation mode\n");
            memmove(&argv[i], &argv[i + 1], (*argc - i) * sizeof(char*));
            (*argc)--;
            return true;
        }
    }
    return false;
}

// This is the function that the enclave will call back into to
// print a message.
void host_helloworld()
{
    fprintf(stdout, "Enclave called into host to print: Hello World!\n");
}


void handle_fault(int signo, siginfo_t * si, void  *ctx)
{
    ucontext_t *uc = (ucontext_t *) ctx;

    switch ( signo )
    {
      case SIGSEGV:
        info("caught SIGSEGV; restoring trigger page access rights");
    	*pte_encl = MARK_EXECUTABLE(*pte_encl);

        sgx_step_do_trap = 1;
	break;

      case SIGTRAP:
        #if DEBUG
            info("Caught single-step trap (RIP=%p)\n", si->si_addr);
        #endif

        if (si->si_addr == sgx_get_aep())
            step_cnt++;

        /* ensure RFLAGS.TF is clear to disable debug single-stepping */
        uc->uc_mcontext.gregs[REG_EFL] &= ~0x100;
        break;

      default:
        info("Caught unknown signal '%d'", signo);
        abort();
    }

    // NOTE: return eventually continues at aep_cb_func and initiates
    // single-stepping mode.
    return;
}

void register_signal_handler(int signo)
{
    struct sigaction act, old_act;

    /* Specify #PF handler with signinfo arguments */
    memset(&act, 0, sizeof(sigaction));
    act.sa_sigaction = handle_fault;
    act.sa_flags = SA_RESTART | SA_SIGINFO;

    /* Block all signals while the signal is being handled */
    sigfillset(&act.sa_mask);
    ASSERT(!sigaction( signo, &act, &old_act ));
}


int benchmark_instructions(void)
{
    /************************************************************************/


    oe_enclave_t* enclave = NULL;
    oe_result_t result;
    // Load enclave
    info_event("loading oe enclave");
    result = oe_create_oe_crypto_app_enclave(
        ENCLAVE_PATH,
        OE_ENCLAVE_TYPE_SGX,
        OE_ENCLAVE_FLAG_DEBUG,
        NULL,
        0,
        &enclave);

    if (result != OE_OK)
    {
        fprintf(stderr, "Failed to create enclave: %s\n", oe_result_str(result));
        return 1;
    }

    print_enclave_info();

    info("dry run");
    // Prepare data
    uint8_t* data = (uint8_t*)DATA;
    uint32_t data_len = (uint32_t)strlen(DATA);
    uint8_t digest[TAG_LEN] = {0};

    uint8_t nonce[NONCE_LEN] = {0x0};

    char *aad = "TCB should be minimized!";
    uint32_t aadlen = strlen(aad);
   

    char *m = "Bare-SGX rocks!";
    uint32_t mlen = strlen(m);
	
	uint8_t mac[MAC_LEN] = {0x0};
    
    uint8_t *ciphertext = malloc(mlen);
    uint8_t *decrypted = malloc(mlen);

    if (ciphertext == NULL || decrypted == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        return -1;
    }

    // Call enclave function
    int retval;
    //oe_encl_op_chacha20poly1305_enc(enclave, &retval, ciphertext, mac, m, mlen, aad, aadlen, nonce);
    //oe_encl_op_chacha20poly1305_dec(enclave, &retval, ciphertext, mac, decrypted, mlen, aad, aadlen, nonce);
    oe_encl_op_return(enclave);
    result = OE_OK;
    retval = 1;
    if (result != OE_OK || retval != 1)
    {
        fprintf(stderr, "Failed to call oe_encl_op_hmac: %s\n", oe_result_str(result));
        oe_terminate_enclave(enclave);
        return 1;
    }

    // Print HMAC result
    printf("Hashing \"Bare-SGX Rocks\" using Open Enclave (HMAC-SHA256):\n");
    printf("hmac=");
    for (int i = 0; i < TAG_LEN; ++i)
        printf("%02x", digest[i]);
    printf("\n");
    
    info_event("configuring attacker runtime");
    printf("%s",ENCLAVE_PATH);
    register_symbols(ENCLAVE_PATH);
    //print_symbols();
    register_aep_cb(aep_cb_func);
    register_signal_handler( SIGSEGV );
    //attacker_config_page_table();

    info("Offset: %i",get_symbol_offset("oe_enter"));
    encl_page = get_symbol_offset("oe_enter") + get_enclave_base();
    info("entry page at %p", encl_page);
    ASSERT(pte_encl = remap_page_table_level(encl_page, PTE));
    info("PTE remapped to pte_encl = %p", pte_encl);
    ASSERT(PRESENT(*pte_encl));
    print_pte(pte_encl);

    *pte_encl = MARK_EXECUTE_DISABLE(*pte_encl);


    /* use hardware trap flag instead of timer aep_cb_funcIRQ */
    register_signal_handler( SIGTRAP );
    set_debug_optin();

    /************************************************************************/
    info_event("single-stepping oe enclave");
    //oe_encl_op_hmac(enclave, &retval, digest, data, data_len);
    //oe_encl_op_chacha20poly1305_enc(enclave, &retval, ciphertext, mac, m, mlen, aad, aadlen, nonce);
    //oe_encl_op_chacha20poly1305_dec(enclave, &retval, ciphertext, mac, decrypted, mlen, aad, aadlen, nonce);
    oe_encl_op_return(enclave);
    info("enclave returned; step_cnt=%d\n", step_cnt);
    // Print HMAC result
    printf("Hashing \"Bare-SGX Rocks\" using Open Enclave (HMAC-SHA256):\n");
    printf("hmac=");
    for (int i = 0; i < TAG_LEN; ++i)
        printf("%02x", digest[i]);
    printf("\n");
    print_args(enclave, ciphertext, mlen, mac, m, mlen, aad, aadlen, nonce, NONCE_LEN);

    oe_terminate_enclave(enclave);
    return 0;

}

int benchmark_timing(void)
{
    oe_enclave_t* enclave = NULL;
    oe_result_t result;
    int retval;
    // Load enclave
    info_event("loading oe enclave");
    result = oe_create_oe_crypto_app_enclave(
        ENCLAVE_PATH,
        OE_ENCLAVE_TYPE_SGX,
        OE_ENCLAVE_FLAG_DEBUG,
        NULL,
        0,
        &enclave);

    if (result != OE_OK)
    {
        fprintf(stderr, "Failed to create enclave: %s\n", oe_result_str(result));
        return 1;
    }

    print_enclave_info();

    info("dry run");
    // Prepare data
    uint8_t* data = (uint8_t*)DATA;
    uint32_t data_len = (uint32_t)strlen(DATA);
    uint8_t digest[TAG_LEN] = {0};

    uint8_t nonce[NONCE_LEN] = {0x0};

    char *aad = "TCB should be minimized!";
    uint32_t aadlen = strlen(aad);
   

    char *m = "Bare-SGX rocks!";
    uint32_t mlen = strlen(m);
	
	uint8_t mac[MAC_LEN] = {0x0};
    
    uint8_t *ciphertext = malloc(mlen);
    uint8_t *decrypted = malloc(mlen);

    if (ciphertext == NULL || decrypted == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        return -1;
    }

    char filename[100];
    time_t rawtime;
    struct tm *timeinfo;

    time(&rawtime);
    timeinfo = localtime(&rawtime);
    strftime(filename, sizeof(filename), "../../data/benchmark-oe/timing/enclave_timing_return_%Y-%m-%d_%H-%M-%S.csv", timeinfo);

    // Allocate buffer for elapsed cycles
    uint64_t *cycles = malloc(ITERATIONS * sizeof(uint64_t));
    if (!cycles) {
        printf("Memory allocation failed\n");
        return 1;
    }

    int result_prepare = prepare_system_for_benchmark(100);
    if (result_prepare == 0) {
        printf("System prepared successfully\n");
    } else {
        printf("Failed to prepare system\n");
    }

    // Perform benchmark and store results
    for (uint32_t i = 0; i < ITERATIONS; ++i) {
        //oe_encl_op_hmac(enclave, &retval, digest, data, data_len);
        oe_encl_op_chacha20poly1305_enc(enclave, &retval, ciphertext, mac, m, mlen, aad, aadlen, nonce);
        oe_encl_op_chacha20poly1305_dec(enclave, &retval, ciphertext, mac, decrypted, mlen, aad, aadlen, nonce);
        //oe_encl_op_return(enclave);
        uint64_t start = rdtsc_begin();
        //oe_encl_op_hmac(enclave, &retval, digest, data, data_len);
        oe_encl_op_chacha20poly1305_enc(enclave, &retval, ciphertext, mac, m, mlen, aad, aadlen, nonce);
        oe_encl_op_chacha20poly1305_dec(enclave, &retval, ciphertext, mac, decrypted, mlen, aad, aadlen, nonce);
        //oe_encl_op_return(enclave);
        uint64_t end = rdtsc_end();

        cycles[i] = end - start;
    }
    printf("Hashing \"Bare-SGX Rocks\" using Open Enclave (HMAC-SHA256):\n");
    printf("hmac=");
    for (int i = 0; i < TAG_LEN; ++i)
        printf("%02x", digest[i]);
    printf("\n");
    print_args(enclave, ciphertext, mlen, mac, m, mlen, aad, aadlen, nonce, NONCE_LEN);

    // Write all results to file after measurements
    FILE *fp = fopen(filename, "w");
    if (!fp) {
        printf("Error opening file %s!\n", filename);
        free(cycles);
        return 1;
    }

    fprintf(fp, "Iteration,ElapsedCycles\n");
    for (uint32_t i = 0; i < ITERATIONS; ++i) {
        fprintf(fp, "%u,%lu\n", i, cycles[i]);
    }

    fclose(fp);
    free(cycles);
    printf("Data written to %s",filename);

}

int main(int argc, const char* argv[])
{
    //benchmark_instructions();
    benchmark_timing();
}
